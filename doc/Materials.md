# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# Динамические библиотеки

Представим, что мы пишем реферат.

- **Статическая библиотека (Static Library, `.a` в Linux):** Это как если бы мы нашли нужную статью в энциклопедии, *вырезали* её ножницами и вклеили прямо в свой реферат.
  
  - *Плюс:* Твой реферат самодостаточен.
  - *Минус:* Реферат стал толстым. Если в энциклопедии нашли ошибку и исправили статью, в твоем реферате останется старая версия. Если 10 человек делают рефераты, у всех будут копии одной и той же статьи (трата бумаги/памяти).

- **Динамическая библиотека (Shared Object, `.so` в Linux / `.dll` в Windows):** Мы просто пишем в реферате: "См. Энциклопедию, том 5, стр. 100".
  
  - *Как это работает:* Когда мы начинаем читать реферат (запускаем программу), мы кладем рядом этот том энциклопедии. Если другой человек тоже читает свой реферат со ссылкой на тот же том, вы можете использовать *одну и ту же книгу* по очереди или вместе.
  - *Плюс:* Программа занимает мало места (код функции лежит отдельно). Если обновить библиотеку (`.so` файл), программа автоматически начнет использовать новую версию без перекомпиляции.
  - *Минус:* Если "потерять" файл библиотеки, программа не запустится.

Итак:

Динамическая библиотека — это файл, содержащий скомпилированный исполняемый код (функции, ресурсы), который **подключается к программе во время ее выполнения (runtime)**, а не на этапе компиляции, как в случае со статическими библиотеками. В Windows такие файлы имеют расширение `.dll`, в Linux — `.so` (Shared Objects).

#### Как устроена динамическая библиотека внутри?

Внутреннее устройство динамической библиотеки — это сложный механизм, который обеспечивает операционной системе возможность загружать и связывать код в процессе работы программы.

- **Формат файла**: Файлы динамических библиотек имеют тот же формат, что и исполняемые файлы (например, PE в Windows, ELF в Linux), но не могут запускаться самостоятельно. Им требуется процесс-хост, в адресное пространство которого они будут загружены.
  
  **PE (Portable Executable)** и **ELF (Executable and Linkable Format)** — это стандартные форматы файлов, используемые операционными системами для хранения исполняемого кода, объектного кода и динамических библиотек.
  
  PE — это формат исполняемых файлов, разработанный Microsoft и используемый в операционных системах семейства **Windows** (32-х и 64-разрядных), а также в средах UEFI. 
  - **Назначение:** Используется для файлов с расширениями `.exe`, `.dll`, `.sys`, `.ocx` и других.
  - **Основа:** Базируется на формате COFF (Common Object File Format).
  - **Структура:** Представляет собой структуру данных, содержащую всю информацию, необходимую загрузчику Windows для отображения файла в память и его выполнения, включая таблицы импорта/экспорта API-функций, данные ресурсов и секции кода/данных.
  - **Совместимость:** Сохраняет заголовок MS-DOS (`MZ`), чтобы обеспечить обратную совместимость и корректную обработку в старых средах.
  
  
  
  ELF — это стандартный формат файлов, широко используемый в операционных системах типа **Unix**, включая **Linux**, FreeBSD и Solaris. 
  
  - **Назначение:** Служит стандартным форматом для исполняемых файлов, объектного кода, общих библиотек (`.so`) и дампов ядра.
  - **Гибкость:** Формат ELF отличается высокой гибкостью и переносимостью между различными аппаратными архитектурами и операционными системами.
  - **Структура:** Файл ELF имеет две основные представления: для компоновщика (linker view), которое оперирует секциями, и для загрузчика (program header view), которое оперирует сегментами, отображаемыми в память.
  - **Стандартизация:** Впервые был опубликован в спецификации интерфейса прикладного двоичного кода (ABI) Unix System V Release 4 (SVR4) и быстро стал общепринятым стандартом.
  
  
- **Экспортируемые символы**: Библиотека содержит таблицу **экспорта** — список функций и данных, которые она предоставляет другим программам. Эти символы могут быть указаны по имени или по порядковому номеру.
- **Таблица импорта**: Приложения, использующие библиотеку, содержат таблицу **импорта**, в которой указано, какие функции из каких библиотек им нужны. Изначально в этой таблице находятся "заглушки" или относительные адреса.
- **Перемещаемый код**: Код в динамической библиотеке обычно является *перемещаемым* (relocatable), то есть он не привязан к конкретному фиксированному адресу в памяти. Это позволяет операционной системе загружать библиотеку туда, где есть свободное место в адресном пространстве процесса.

#### Процесс динамического связывания

1. **На этапе компиляции/сборки**: Компоновщик (linker) не копирует код библиотеки в исполняемый файл. Вместо этого он просто добавляет информацию о том, какие библиотеки нужны и какие функции из них будут использоваться (таблица импорта).
2. **На этапе загрузки/выполнения**: Когда пользователь запускает программу, **динамический загрузчик** (часть операционной системы) берет управление на себя.
3. **Загрузка**: Загрузчик находит необходимые DLL/SO файлы на диске (обычно по определенным путям в системе) и загружает их в оперативную память.
4. **Связывание (Relocation)**: Загрузчик "исправляет" ссылки и адреса внутри программы и библиотеки. Он заменяет "заглушки" в таблице импорта программы на фактические адреса функций, по которым библиотека была загружена в память.

#### Преимущества

- **Экономия памяти**: Несколько запущенных программ могут использовать одну и ту же копию библиотеки в оперативной памяти, что экономит системные ресурсы.
- **Меньший размер исполняемых файлов**: Основной исполняемый файл приложения не содержит всего кода библиотек, он легче и быстрее загружается.
- **Модульность и обновление**: Можно обновить или исправить ошибку в библиотеке, не перекомпилируя при этом все приложения, которые ее используют.
- **Расширяемость**: Динамические библиотеки часто используются как плагины для расширения функциональности программ.

### 2. Что такое "Контракт"?

В языках вроде Java или C# есть слово `interface`. В языке C этого нет, но концепция та же.

**Контракт** — это договоренность о том, как выглядит функция, но не о том, как она работает внутри. Это **сигнатура** функции.

Для нашего задания контракт состоит из двух функций:

1. `int PrimeCount(int A, int B);`
2. `float E(int x);`

Наши **Программа №1** и **Программа №2** ничего не знают о том, *как* считаются простые числа (решетом Эратосфена или перебором). Они знают только *контракт*: "Если я дам функции два числа `int`, она вернет мне `int`".

Это позволяет подменять одну библиотеку другой. Пока имена функций и типы аргументов совпадают (контракт соблюден), программе все равно, какую именно библиотеку она использует.

### 3. Два способа использования

#### Способ 1: На этапе линковки (Compile-time / Load-time linking)

Это для **Программы №1**. Ты компилируешь программу и говоришь компилятору: "Эй, функции `PrimeCount` и `E` лежат вот в этом `.so` файле". ОС при запуске программы сама найдет этот файл, загрузит его в память и свяжет вызовы.

- *Инструменты:* ключи компилятора `-L` (где искать) и `-l` (как называется библиотека).

#### Способ 2: Во время исполнения (Runtime linking)

Это для **Программы №2**. Программа компилируется вообще без библиотек. В коде ты используешь специальные системные вызовы (функции ОС), чтобы загрузить код "руками". Это работает как плагины. Программа работает, пользователь нажал "0", программа выгрузила старую библиотеку и загрузила новую.

Тебе понадобятся функции из библиотеки `<dlfcn.h>`:

1. `void* handle = dlopen("./lib1.so", RTLD_LAZY);` — "Операционная система, открой мне файл `lib1.so` и верни указатель (хэндл) на него".

1. `dlsym(handle, "PrimeCount");` — "Найди внутри этой библиотеки функцию с именем `PrimeCount` и дай мне её адрес в памяти". Ты сохранишь этот адрес в указатель на функцию.
2. `dlclose(handle);` — "Я закончил, выгружай библиотеку".

#### Немного подробнее

1. `dlopen`

`dlopen` используется для загрузки указанной динамической библиотеки в адресное пространство текущего процесса.

**Прототип:**

```c
void* dlopen(const char* filename, int flags);
```

**Принимает:**

- `filename`: Путь к файлу библиотеки (например, `"./libfoo.so"`, `"libm.so"`). Если указано только имя файла без пути, система использует стандартные пути поиска (например, переменные окружения `LD_LIBRARY_PATH` или `/usr/lib`).
- `flags`: Флаги, управляющие процессом загрузки и разрешения символов. Наиболее распространенные:
  - `RTLD_LAZY`: (Ленивое связывание) Разрешает символы (функции) только по мере их фактического вызова.
  - `RTLD_NOW`: (Немедленное связывание) Разрешает все символы сразу при загрузке библиотеки. Если какой-то символ не найден, `dlopen` завершится ошибкой.
  - `RTLD_GLOBAL`: Делает экспортируемые символы библиотеки доступными для других динамически загружаемых библиотек.
  - `RTLD_LOCAL`: Символы доступны только текущему процессу (используется по умолчанию).

**Возвращает:**

- При успешном выполнении: **Хэндл (handle)** — указатель типа `void*`, который представляет загруженную библиотеку. Этот хэндл используется в дальнейшем для `dlsym` и `dlclose`.
- В случае ошибки: `NULL`. Детальное описание ошибки можно получить с помощью функции `dlerror()`.

##### Важное примечание:

В контексте динамических библиотек (`.dll` или `.so`), символы функции играют роль публичного интерфейса, "контракта" между библиотекой и программой, которая ее использует.

1. **Имя функции в коде**: Когда вы пишете `printf("Hello")` в своей программе на языке Си, `printf` — это символ функции.
2. **Экспорт символа**: Внутри библиотеки (например, `libc.so`), функция `printf` "помечается" как **экспортируемый символ**. Это означает, что она доступна для использования извне. Библиотека ведет специальную таблицу экспорта, где написано: "Функция с именем `printf` находится по адресу такому-то внутри меня".
3. **Импорт символа**: Ваша программа содержит таблицу **импорта**, где указано: "Мне нужна функция с именем `printf` из библиотеки `libc.so`".

Как это связано с `dlsym`

Функция `dlsym(handle, "cos")` работает как раз с этими именами (символами):

- `"cos"` — это строка, содержащая имя символа (функции), которую вы хотите найти.
- `dlsym` ищет эту строку в таблице экспорта библиотеки, на которую указывает `handle`.
- Если имя найдено, она возвращает адрес (указатель) на начало машинного кода этой функции.

Декорирование имен (Name Mangling)

Важно отметить, что в языках вроде C++ имена символов часто "декорируются" или "искажаются" (name mangling). Это необходимо, чтобы поддерживать перегрузку функций (когда несколько функций имеют одно и то же имя, но разные параметры).

Например, в C++ функция `int myFunc(int a)` может получить символ вроде `_Z6myFunci`, а функция `int myFunc(double a)` — символ `_Z6myFuncd`.

В языке C по умолчанию декорирования нет, поэтому имена символов обычно совпадают с именами функций в исходном коде, что упрощает их поиск через `dlsym`.

---

2. `dlsym`

`dlsym` (от "dynamic linker symbol") используется для поиска адреса конкретного символа (обычно функции или глобальной переменной) внутри ранее загруженной библиотеки.

**Прототип:**

```c
void* dlsym(void* handle, const char* symbol);
```

**Принимает:**

- `handle`: Хэндл библиотеки, полученный ранее от функции `dlopen`.
- `symbol`: Имя символа (функции или переменной) в виде строки (например, `"cos"` для поиска функции косинуса).

**Возвращает:**

- При успешном выполнении: **Адрес символа** (указатель `void*`). Этот указатель затем приводится к правильному типу функции/переменной для использования.
- В случае ошибки: `NULL`. (Важно: `NULL` может также означать, что функция найдена, но ее адрес нулевой. Для надежной проверки ошибок всегда вызывайте `dlerror()` до и после `dlsym`).

---

3. `dlclose`

`dlclose` используется для выгрузки библиотеки из адресного пространства процесса и освобождения связанных с ней ресурсов.

**Прототип:**

```c
int dlclose(void* handle);
```

**Принимает:**

- `handle`: Хэндл библиотеки, полученный от `dlopen`.

**Возвращает:**

- `0` при успешном выполнении.
- Не `0` в случае ошибки. Описание ошибки доступно через `dlerror()`.

**Важно:** `dlclose` не обязательно выгружает библиотеку немедленно. Операционная система использует счетчик ссылок (reference count). Библиотека будет физически выгружена из памяти только тогда, когда счетчик ссылок станет равен нулю, то есть когда все вызовы `dlopen` для нее будут сбалансированы вызовами `dlclose`.

Пример использования:

```c
#include <stdio.h>
#include <dlfcn.h> // Необходимый заголовочный файл

int main() {    
    void* handle;
    double (*cosine)(double); // Указатель на функцию, принимающую double и возвращающую double
    const char* error;
  
    // 1. Загружаем библиотеку libm.so (библиотека стандартных математических функций)
    handle = dlopen("libm.so.6", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "%s\n", dlerror());
        return 1;
    }
    dlerror();    // Очищаем предыдущие ошибки

    // 2. Ищем функцию cos
    *(void**)(&cosine) = dlsym(handle, "cos");
    if ((error = dlerror()) != NULL) {
        fprintf(stderr, "%s\n", error);
        dlclose(handle); // Закрываем при ошибке поиска
        return 1;
    }
    // 3. Используем найденную функцию
    printf("cos(2.0) = %f\n", (*cosine)(2.0));
    // 4. Выгружаем библиотеку
    dlclose(handle);
    return 0;
}
```
