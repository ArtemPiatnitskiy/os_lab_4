# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# Что такое разделяемая память (Shared Memory)?

Представим, что у каждого процесса есть свой собственный, изолированный "блокнот" с данными (его адресное пространство). Ни один процесс не может заглянуть в блокнот другого. Это сделано для безопасности и стабильности системы.

**Разделяемая память (Shared Memory, SHM)** — это специальный механизм, который позволяет операционной системе выделить один "общий блокнот" и "вклеить" его страницы в адресные пространства нескольких процессов.

<img title="" src="https://media.geeksforgeeks.org/wp-content/uploads/20240710145648/Screenshot-2024-07-10-131723.png" alt="" data-align="center">

Для процессов этот "общий блокнот" выглядит как обычный участок их собственной памяти. Они могут читать из него и писать в него так же, как в обычный массив. Но как только один процесс что-то записывает в эту область, изменения **мгновенно** становятся видны всем остальным процессам, у которых эта память подключена.

Это самый быстрый способ обмена данными, потому что данные не копируются из одного процесса в другой (как в pipe), а лежат в одном общем месте.

---

# Системные вызовы для работы с разделяемой памятью (POSIX)

Для работы с SHM в Linux-подобных системах обычно используются системные вызовы стандарта POSIX. Вот основные из них:

1. `shm_open()`: Это "создатель" нашего общего блокнота. Функция создает или открывает объект разделяемой памяти. Взамен вы получаете файловый дескриптор, похожий на тот, что мы получаем при работе с файлами.
   
   Его работа аналогична системному вызову `open()` для обычных файлов.
   
   Функция принимает три параметра: 
   
   1. **`name`**: Указатель на строку, завершающуюся нулевым символом, которая служит именем объекта разделяемой памяти. Для переносимости (портативности) имя должно начинаться с символа косой черты `/`, за которым следует один или более символов (без дополнительных косых черт).
   
   2. **`oflag`**: Битовая маска, определяющая режим открытия объекта (аналогично `open()`). Обязательно должен присутствовать один из следующих флагов:
      
      - `O_RDONLY`: Открытие только для чтения.
      - `O_RDWR`: Открытие для чтения и записи.
      
      Также можно использовать дополнительные флаги, объединяя их через оператор битового ИЛИ (`|`):
      
      - `O_CREAT`: Создать объект разделяемой памяти, если он не существует.
      - `O_EXCL`: Используется вместе с `O_CREAT`. Если объект с таким именем уже существует, `shm_open()` вернет ошибку, а `errno` будет установлено в `EEXIST`.
      - `O_TRUNC`: Если объект уже существует, он будет усечен до длины 0 байтов.
   
   3. **`mode`**: Разрешения доступа (права доступа) к объекту разделяемой памяти, аналогичные правам доступа к файлам в Unix (например, `S_IRUSR` для чтения владельцем, `S_IWUSR` для записи владельцем). Этот параметр используется только в том случае, если в `oflag` указан флаг `O_CREAT`.
      
      | Константа | Описание права доступа (POSIX)                    | Эквивалент в umask/chmod |
      | --------- | ------------------------------------------------- | ------------------------ |
      | `S_IRUSR` | Право на **чтение** для **владельца** (User)      | `u+r`                    |
      | `S_IWUSR` | Право на **запись** для **владельца** (User)      | `u+w`                    |
      | `S_IXUSR` | Право на **выполнение** для **владельца** (User)  | `u+x`                    |
      | `S_IRWXU` | Чтение, запись, выполнение для **владельца**      | `u+rwx`                  |
      | `S_IRGRP` | Право на **чтение** для **группы** (Group)        | `g+r`                    |
      | `S_IWGRP` | Право на **запись** для **группы** (Group)        | `g+w`                    |
      | `S_IXGRP` | Право на **выполнение** для **группы** (Group)    | `g+x`                    |
      | `S_IRWXG` | Чтение, запись, выполнение для **группы**         | `g+rwx`                  |
      | `S_IROTH` | Право на **чтение** для **остальных** (Other)     | `o+r`                    |
      | `S_IWOTH` | Право на **запись** для **остальных** (Other)     | `o+w`                    |
      | `S_IXOTH` | Право на **выполнение** для **остальных** (Other) | `o+x`                    |
      | `S_IRWXO` | Чтение, запись, выполнение для **остальных**      | `o+rwx`                  |
   
   4. **При ошибке**: Функция возвращает **-1** и устанавливает глобальную переменную `errno` для указания типа ошибки (например, `EACCES` при отказе в доступе, `ENOENT` если объект не существует без флага `O_CREAT`)
   - `shm_open("my_shm", O_CREAT | O_RDWR, S_IWUSR);`

2. `ftruncate()`: После создания объекта SHM он имеет размер 0. Этой функцией мы "задаем размер" общему блокноту.
   
   Основная задача `ftruncate()` — гарантировать, что объект имеет определенную длину в байтах.
   
   В контексте работы с разделяемой памятью (после вызова `shm_open()`), этот вызов **критически важен**, так как вновь созданный объект разделяемой памяти изначально имеет размер 0 байтов. Прежде чем вы сможете отобразить его в память процесса с помощью `mmap()` и начать с ним работать, вы должны задать ему нужный размер с помощью `ftruncate()`.
   
   ```c
   #include <unistd.h>
   #include <sys/types.h>
   
   int ftruncate(int fd, off_t length);
   ```
   
   - `ftruncate(fd, size);`
     
     Параметры:
     
     1. **`fd` (file descriptor):** Целочисленный файловый дескриптор, который был ранее получен в результате успешного вызова `open()`, `shm_open()` или подобной функции.
     2. **`length` (длина):** Новая длина объекта в байтах (тип `off_t`).
     
     **Если новая длина (`length`) меньше текущего размера объекта:** Данные в конце объекта обрезаются и становятся недоступными.
   
   - **Если новая длина (`length`) больше текущего размера объекта:** Размер объекта увеличивается. Область, добавленная в конец (пространство между старым концом и новым концом), заполняется нулевыми байтами (null bytes, `\0`).
   
   Возвращаемое значение
   
   - **0:** В случае успешного выполнения.
   - **-1:** В случае ошибки. При этом устанавливается соответствующее значение в глобальной переменной `errno` (например, `EBADF` если дескриптор недействителен, или `EFBIG` если размер превышает максимальный лимит файловой системы).

3. `mmap()`: Это ключевая функция. Она берет созданный и настроенный объект SHM и **отображает (подключает)** его в адресное пространство нашего процесса. Взамен мы получаем указатель, с которым можно работать как с обычным массивом в C.
   
   ```c
   #include <sys/mman.h>
   #include <sys/stat.h> /* для констант режима (mode) */
   #include <fcntl.h>    /* для констант флагов (flags) */
   #include <unistd.h>   /* для off_t */
   
   void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
   ```
   
   Параметры:
   
   Функция принимает шесть аргументов:
   
   1. **`addr` (address):** Предпочтительный адрес в виртуальном адресном пространстве процесса, куда будет отображен объект.
      
      - Чаще всего используется значение **`NULL`**. В этом случае ядро операционной системы автоматически выбирает подходящий, неиспользуемый адрес страницы памяти.
   
   2. **`length` (длина):** Количество байтов, которое нужно отобразить, начиная от заданного смещения (`offset`). Размер должен быть ненулевым.
   
   3. **`prot` (protection):** Битовая маска, определяющая желаемые права доступа к отображенной области памяти. Обязательно должен быть указан как минимум один из флагов:
      
      - `PROT_NONE`: Доступ запрещен.
      - `PROT_READ`: Страницы доступны для чтения.
      - `PROT_WRITE`: Страницы доступны для записи (используется для изменения файла/памяти).
      - `PROT_EXEC`: Страницы доступны для выполнения (как код).
      
      Эти флаги объединяются оператором `|` (например, `PROT_READ | PROT_WRITE`).
   
   4. **`flags` (флаги отображения):** Определяют тип отображения и поведение при изменениях. Обязательно должен присутствовать один из следующих флагов:
      
      - `MAP_SHARED`: Изменения, внесенные в отображенную память, **видны другим процессам**, которые отобразили тот же объект (и записываются обратно в файл/shm объект). Это ключевой флаг для **разделяемой памяти**.
      - `MAP_PRIVATE`: Изменения, внесенные в память, **не видны другим процессам** и не записываются обратно в исходный файл (создается копия при записи).
      
      Также часто используется дополнительный флаг `MAP_FIXED` (используется редко, требует точного `addr`).
   
   5. **`fd` (file descriptor):** Файловый дескриптор открытого объекта, который мы хотим отобразить (например, результат вызова `shm_open()` или `open()`).
   
   6. **`offset` (смещение):** Смещение в байтах от начала файла или объекта, откуда начнется отображение. Должно быть выровнено по границе страницы памяти (обычно кратно размеру страницы, который можно получить через `getpagesize()` или `sysconf(_SC_PAGESIZE)`). Обычно используется `0`.
   
   Возвращаемое значение
   
   - **При успешном выполнении:** Функция возвращает **указатель на тип `void*`**, который указывает на начало отображенной области памяти в адресном пространстве процесса. Этот указатель нужно привести к нужному типу (например, `char*`, `int*`, `struct*`).
   
   - **При ошибке:** Функция возвращает специальное значение **`MAP_FAILED`** (которое определено как `(void *) -1`). При этом устанавливается глобальная переменная `errno` для указания типа ошибки.
   
   - `mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);`
   
   ```c
   #include <sys/mman.h>
   #include <fcntl.h>
   #include <unistd.h>
   #include <stdio.h>
   
   int main() {
       // ... (предполагается, что shm_open и ftruncate выполнены успешно)
       int permissions = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
       int fd = shm_open("/my_shm", O_RDWR, permissions);
       ftruncate(fd, 4096);
   
       // Отображаем объект разделяемой памяти в адресное пространство процесса
       void *ptr = mmap(NULL,          // addr: Ядро само выберет адрес
                        4096,          // length: Размер отображения
                        PROT_READ | PROT_WRITE, // prot: Права чтения/записи
                        MAP_SHARED,    // flags: Разделяемая память
                        fd,            // fd: Файловый дескриптор
                        0);            // offset: Начиная с начала объекта
   
       if (ptr == MAP_FAILED) {
           perror("mmap failed");
           return 1;
       }
   
       // Теперь можно использовать ptr как обычный указатель:
       sprintf((char*)ptr, "Привет, мир!");
   
       // Не забываем освобождать ресурсы:
       munmap(ptr, 4096);      // Удаляем отображение памяти
       close(fd);              // Закрываем файловый дескриптор
       shm_unlink("/my_shm");  // Удаляем объект разделяемой памяти из системы
   
       return 0;
   }
   ```

4. `munmap()`: Когда работа с памятью завершена, ее нужно "отключить" от процесса.
   
   Это обратная операция к системному вызову `mmap()`.
   
   Когда мы вызываем `mmap()`, мы создаём связь между файлом/объектом разделяемой памяти и диапазоном адресов в процессе. `munmap()` разрывает эту связь.
   
   Основные последствия вызова `munmap()`:
   
   1. **Память становится недоступной:** После успешного вызова `munmap()` попытка доступа к адресам, которые ранее занимала отображенная область (начиная с указателя, возвращенного `mmap()`), приведет к ошибке сегментации (Segmentation Fault, `SIGSEGV`).
   2. **Синхронизация данных (для `MAP_SHARED`):** Если область была отображена с флагом `MAP_SHARED`, любые изменения, внесенные в память до вызова `munmap()`, гарантированно записываются обратно в базовый объект разделяемой памяти или файл.
   3. **Освобождение ресурсов:** Часть виртуального адресного пространства процесса освобождается и может быть использована для других целей.
   
   Параметры
   
   1. **`addr` (address):** Указатель на **начальный адрес** отображенной области памяти. Это должен быть тот самый указатель, который был возвращен системным вызовом `mmap()` (или адрес, кратный размеру страницы памяти внутри отображенной области).
   2. **`length` (длина):** Длина отображенной области в байтах. Она должна точно совпадать с тем значением `length`, которое использовалось при вызове `mmap()`.
   - `munmap(ptr, size);`

5. `shm_unlink()`: Когда "общий блокнот" больше не нужен ни одному процессу, его нужно удалить из системы, чтобы не утекала память.
   
   - `shm_unlink("my_shm") = 0`
     
     Это сам системный вызов с его аргументом (именем объекта).
     
     **`= 0`**: Это **возвращаемое значение** системного вызова.
     
     - `0` означает **успех** (объект был успешно удален или помечен для удаления).
     
     - Если бы объект не существовал, `strace` мог бы показать ошибку, например:
       
       ```bash
       shm_unlink("non_existent_shm") = -1 ENOENT (No such file or directory)
       ```

### Разделяемая память vs. Каналы (Pipes)

| Критерий             | Каналы (Pipes)                                                                                                                                       | Разделяемая память (Shared Memory)                                                                                                                                                                      |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Скорость**         | Медленнее. Данные копируются из адресного пространства одного процесса в ядро, а затем из ядра в адресное пространство другого.                      | **Самый быстрый IPC**. Данные не копируются. Все процессы работают с одной и той же областью памяти.                                                                                                    |
| **Синхронизация**    | **Встроена**. Pipe — это по сути очередь. Если один процесс пишет, другой читает. Ядро ОС само заботится о том, чтобы процессы не мешали друг другу. | **Отсутствует!** Это самый большой недостаток и главная сложность. Если два процесса попытаются записать данные одновременно, получится "каша" (состояние гонки). Нужны внешние средства синхронизации. |
| **Структура данных** | Поток байт (stream). Неструктурированный.                                                                                                            | Любая структура. Вы можете разместить в общей памяти `struct`, массив, что угодно. Это очень гибко.                                                                                                     |
| **Направление**      | Однонаправленный (Unidirectional). Для двусторонней связи нужно два канала.                                                                          | Двунаправленный по своей природе. Все могут и читать, и писать (если разрешено).                                                                                                                        |
| **Сложность**        | Проще в использовании из-за встроенной синхронизации.                                                                                                | Сложнее, так как требует ручного управления синхронизацией (семафоры, мьютексы).                                                                                                                        |

# Важнейший аспект: Синхронизация

Как было сказано выше, с SHM возникает проблема: как процессам координировать свои действия?

- `Child1` должен начать работу только **после** того, как `Parent` записал данные.
- `Child2` должен начать работу только **после** того, как `Child1` закончил.
- `Parent` должен вывести результат только **после** того, как `Child2` закончил.

Эту координацию обеспечивают **семафоры** или **мьютексы**. Для нашей задачи семафоры подходят идеально. Семафор — это, по сути, счетчик, который процессы могут атомарно (неделимо) увеличивать или уменьшать, чтобы сигнализировать друг другу.

# Семафоры

Представьте себе парковку с ограниченным количеством мест, скажем, **5**. У въезда стоит электронное табло, которое показывает количество свободных мест.

- **Семафор** — это и есть это табло со счетчиком. Его начальное значение — 5.
- **Процесс** — это автомобиль, который хочет припарковаться (получить доступ к ресурсу).

Теперь две основные операции:

1. **`sem_wait()` (Попытка въехать)**
   
   - Водитель смотрит на табло.
   - **Если счетчик > 0:** Он въезжает. Счетчик **немедленно уменьшается на 1**. Теперь он `4`. Эта операция (проверка и уменьшение) происходит **атомарно** — то есть, два водителя не могут одновременно увидеть `1` место и оба въехать. Система гарантирует, что это произойдет как одно неделимое действие.
   - **Если счетчик == 0:** Ворота закрыты. Водитель **останавливается и ждет** в очереди у въезда. Его процесс "засыпает" (блокируется) и не тратит процессорное время.

2. **`sem_post()` (Выезд с парковки)**
   
   - Водитель, который был внутри, выезжает.
   - Он нажимает кнопку на выезде. Счетчик **немедленно увеличивается на 1**.
   - Если у въезда была очередь из ждущих машин, система дает "зеленый свет" **одной** из них, которая тут же въезжает (выполняя свой `sem_wait`) и уменьшает счетчик обратно.

**Ключевая идея:** Семафор — это просто защищенный от одновременного доступа счетчик, который используется для управления доступом к ограниченному количеству ресурсов.

В нашем случае ресурс один — право на запись/чтение в разделяемую память. Поэтому мы будем использовать семафоры с начальным значением `0` (все ворота изначально закрыты) или `1` (одно место свободно). Такой семафор с двумя состояниями (0 или 1) называется **двоичным (binary) семафором** и по сути работает как замок (мьютекс).

### Типы семафоров (POSIX)

1. **Неименованные семафоры (`sem_init`)**: Живут в памяти. Их нужно вручную размещать в разделяемой памяти, чтобы разные процессы могли их видеть. Это сложнее. Они отлично подходят для потоков (threads) внутри *одного* процесса.
2. **Именованные семафоры (`sem_open`)**: Управляются ядром ОС и доступны по имени (например, `"/my_cool_semaphore"`). Любой процесс, знающий имя, может их открыть и использовать. **Это то, что вам нужно для взаимодействия между разными программами.**

Далее мы будем говорить только про **именованные** семафоры.

### Основные команды (функции API)

Для работы с ними нужно подключить заголовочный файл `<semaphore.h>` и компоновать программу с флагом `-lpthread` (на некоторых системах).

#### 1. `sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);`

- **Что делает:** Создает новый или открывает существующий именованный семафор.
- **Параметры:**
  - `name`: Имя семафора. **Важная тонкость:** имя должно начинаться со слэша `/` и не содержать других слэшей (например, `"/my_sem1"`).
  - `oflag`: Флаги. Самый важный — `O_CREAT`. Если он указан, семафор будет создан, если не существует. Можно комбинировать с `O_EXCL`, чтобы выдать ошибку, если семафор уже существует.
  - `mode`: Права доступа (как у файлов, например, `0666`), если семафор создается.
  - `value`: **Начальное значение счетчика** (только при создании). В вашем случае это будет `0`.
- **Возвращает:** Указатель на семафор `sem_t*` в случае успеха или `SEM_FAILED` в случае ошибки.

```c
// В родительском процессе
sem_t *sem1 = sem_open("/task_for_child1", O_CREAT, 0666, 0);
if (sem1 == SEM_FAILED) {
    perror("sem_open");
    exit(EXIT_FAILURE);
}
```

#### 2. `int sem_wait(sem_t *sem);`

- **Что делает:** "Ожидать" или "взять". Уменьшает значение семафора на 1.
- **Поведение:** Если значение семафора `> 0`, оно уменьшается, и функция немедленно возвращается. Если значение `== 0`, процесс **блокируется** (засыпает) до тех пор, пока другой процесс не вызовет `sem_post`.
- **Возвращает:** `0` в случае успеха, `-1` в случае ошибки.

```c
// В Child1, в начале цикла
printf("Child1 ждет данных...\n");
sem_wait(sem1); // Процесс здесь "замрет", пока родитель не сделает post
printf("Child1 проснулся и начал работу!\n");
```

#### 3. `int sem_post(sem_t *sem);`

- **Что делает:** "Отпустить" или "освободить". Увеличивает значение семафора на 1.
- **Поведение:** Если есть процессы, заблокированные в `sem_wait()` на этом семафоре, один из них "просыпается" и продолжает выполнение. Если ждущих нет, просто увеличивается счетчик.
- **Возвращает:** `0` в случае успеха, `-1` в случае ошибки.

```c
// В родительском процессе, после записи данных в SHM
printf("Родитель положил данные, подает сигнал...\n");
sem_post(sem1); // "Разбудить" Child1
```

#### 4. `int sem_close(sem_t *sem);`

- **Что делает:** Закрывает соединение с семафором для **данного процесса**. Аналогично `close()` для файла. Сам семафор из системы не удаляется.
- **Тонкость:** Каждый процесс, открывший семафор, должен его закрыть перед выходом.

#### 5. `int sem_unlink(const char *name);`

- **Что делает:** Удаляет имя семафора из системы.
- **Тонкость:** Это критически важная функция для очистки. Вызывать ее должен только один процесс (обычно родительский) после того, как все дочерние процессы завершились и все семафоры были закрыты через `sem_close`. Если не вызвать `sem_unlink`, семафоры останутся в системе "висеть" даже после перезагрузки! Их придется удалять вручную из `/dev/shm/`.

# Взаимоблокировки (пример)

Представьте ситуацию, в которой участвуют:

- **Два процесса:** Процесс P1 и Процесс P2.
- **Два ресурса:** Ресурс R1 (например, принтер) и Ресурс R2 (например, сканер).
- **Два семафора/блокировки:** `Lock1` для R1 и `Lock2` для R2.

Сценарий взаимоблокировки

Последовательность действий, приводящая к тупику:

| Время  | Процесс P1                                                  | Процесс P2                                                  |
| ------ | ----------------------------------------------------------- | ----------------------------------------------------------- |
| **T1** | Захватывает `Lock1` (получает доступ к Принтеру R1).        | Захватывает `Lock2` (получает доступ к Сканеру R2).         |
| **T2** | Пытается захватить `Lock2` (ему нужен Сканер R2).           | Пытается захватить `Lock1` (ему нужен Принтер R1).          |
| **T3** | **Блокируется**, потому что `Lock2` уже занят процессом P2. | **Блокируется**, потому что `Lock1` уже занят процессом P1. |

**Результат:**

Оба процесса находятся в состоянии бесконечного ожидания. 

- P1 ждет, пока P2 освободит R2.
- P2 ждет, пока P1 освободит R1.

Ни один из процессов не может продолжить выполнение, ни один не может освободить свой ресурс, так как ждет чужой ресурс, необходимый для завершения работы. Возникает **взаимная блокировка**. Система "зависает" в этой части.

Условия возникновения Deadlock

Чтобы произошла взаимоблокировка, должны одновременно выполняться четыре условия (условия Коффмана):

1. **Взаимное исключение:** Ресурсом может пользоваться только один процесс за раз (как в примере с принтером/сканером).
2. **Удержание и ожидание:** Процесс, уже владеющий одним ресурсом, может запрашивать новый ресурс, не освобождая старый.
3. **Отсутствие принудительного освобождения:** Ресурс может быть освобожден только добровольно процессом-владельцем (мы не можем просто "отнять" принтер у P1).
4. **Круговое ожидание:** Существует кольцевая цепочка процессов, где каждый процесс ждет ресурс, занятый следующим процессом в цепочке (P1 ждет R2, P2 ждет R1). 

Как предотвратить?

Один из самых распространенных способов предотвращения этой конкретной ситуации — **единообразный порядок захвата ресурсов**. Если бы оба процесса всегда пытались захватить `Lock1` *перед* `Lock2`, взаимоблокировка была бы невозможна.

Подробнее можно почитать на [сайте](https://moodle.kstu.ru/mod/page/view.php?id=56)
